# openSEF Architecture R&D

**The Complete Research Foundation for Building a Premium Desktop Environment**

---

## Table of Contents

1. [Rendering Pipeline Analysis](#part-1-rendering-pipeline-analysis)
2. [GNUStep Deep Dive](#part-2-gnustep-deep-dive)
3. [macOS Cocoa & Core Animation](#part-3-macos-cocoa--core-animation)
4. [GhostBSD Gershwin Study](#part-4-ghostbsd-gershwin-study)
5. [Implementation Roadmap](#part-5-implementation-roadmap)
6. [Boot, Lock Screen & Shutdown UI](#part-6-boot-lock-screen--shutdown-ui)

---

# Part 1: Rendering Pipeline Analysis

## 1.1 The Three Approaches

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Desktop Rendering Models                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  X11 (Legacy)                                                       │
│  Client → X Server → Compositor → Display                          │
│  Problem: Round-trips, tearing, no isolation                        │
│                                                                     │
│  Wayland (Modern - openSEF uses this)                               │
│  Client → Buffer → Compositor (direct) → Display                   │
│  Benefit: No tearing, direct rendering, isolation                   │
│                                                                     │
│  macOS (Gold standard)                                              │
│  App → Core Animation → WindowServer → Display                      │
│  Benefit: Implicit animations, presentation tree                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

## 1.2 Wayland Architecture (What We Use)

```
┌─────────────────────────────────────────────────────────────────────┐
│  Client (App)                    Compositor (openSEF)               │
│  ┌──────────────────┐           ┌──────────────────────────┐       │
│  │ Draws to buffer  │  Wayland  │  wlr_scene composites    │       │
│  │ (GPU/SHM)        │ ─Protocol→│  all buffers to GPU      │       │
│  └──────────────────┘           └──────────────────────────┘       │
│                                                                     │
│  Key: Clients NEVER touch the screen directly.                      │
│       Compositor has FULL control.                                  │
└─────────────────────────────────────────────────────────────────────┘
```

## 1.3 macOS WindowServer (What We Emulate)

```
┌─────────────────────────────────────────────────────────────────────┐
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────────┐ │
│  │   AppKit    │ →  │ Core Anim.  │ →  │     WindowServer        │ │
│  │  (NSView)   │    │  (CALayer)  │    │   (Quartz Compositor)   │ │
│  └─────────────┘    └─────────────┘    └─────────────────────────┘ │
│        ↑                  ↑                       ↑                 │
│   App Process        Render Tree          Separate Process         │
│   Main Thread        GPU Textures         60fps Compositing        │
└─────────────────────────────────────────────────────────────────────┘
```

---

# Part 2: GNUStep Deep Dive

## 2.1 Class Hierarchy

```
NSObject
├── NSResponder           ← Event handling chain
│   ├── NSView           ← Visual content, drawing
│   │   └── NSWindow     ← Window management
│   └── NSApplication    ← Main app object
├── NSEvent              ← Input events
├── NSRunLoop            ← Main loop
└── NSAnimation          ← Animations
```

## 2.2 NSView Dirty Rectangle Algorithm

**The Core Pattern:**
```cpp
// openSEF C++ translation of NSView

class OSFView : public OSFResponder {
public:
    void setNeedsDisplay(bool flag = true) {
        if (flag) {
            setNeedsDisplayInRect(bounds_);
        } else {
            needsDisplay_ = false;
            invalidRects_.clear();
        }
    }
    
    void setNeedsDisplayInRect(const OSFRect& rect) {
        OSFRect clipped = rect.intersect(bounds_);
        if (clipped.isEmpty()) return;
        
        invalidRects_.push_back(clipped);
        needsDisplay_ = true;
        
        if (auto w = window()) {
            w->setViewsNeedDisplay(true);
        }
    }
    
    void displayIfNeeded() {
        if (!needsDisplay_) return;
        
        OSFRect dirtyRect;
        for (const auto& r : invalidRects_) {
            dirtyRect = dirtyRect.unionWith(r);
        }
        
        drawRect(dirtyRect);
        invalidRects_.clear();
        needsDisplay_ = false;
    }
    
    virtual void drawRect(const OSFRect& dirtyRect) = 0;
    
private:
    OSFRect bounds_, frame_;
    std::vector<OSFRect> invalidRects_;
    bool needsDisplay_ = false;
};
```

## 2.3 NSResponder Event Chain

```cpp
class OSFResponder {
public:
    virtual void mouseDown(OSFEvent* event) {
        if (nextResponder_) nextResponder_->mouseDown(event);
    }
    virtual void keyDown(OSFEvent* event) {
        if (nextResponder_) nextResponder_->keyDown(event);
    }
    
    void setNextResponder(OSFResponder* next) { nextResponder_ = next; }
    
protected:
    OSFResponder* nextResponder_ = nullptr;
};

// Chain: View → Superview → ... → Window → App
```

## 2.4 Animation Timing

```cpp
enum class OSFAnimationCurve { Linear, EaseIn, EaseOut, EaseInOut, Spring };

float applyCurve(float t, OSFAnimationCurve curve) {
    switch (curve) {
        case Linear:    return t;
        case EaseIn:    return t * t * t;
        case EaseOut:   return 1.0f - std::pow(1.0f - t, 3.0f);
        case EaseInOut: return t < 0.5f ? 4*t*t*t : 1 - std::pow(-2*t + 2, 3) / 2;
        case Spring: {
            float omega = 10.0f, zeta = 0.5f;
            return 1 - std::exp(-zeta * omega * t) * 
                   std::cos(omega * std::sqrt(1 - zeta*zeta) * t);
        }
    }
}
```

---

# Part 3: macOS Cocoa & Core Animation

## 3.1 The Three Layer Trees

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Model Tree    │    │ Presentation    │    │   Render Tree   │
│  What you SET   │ →  │  What you SEE   │ →  │  GPU Rendering  │
│  (target state) │    │  (current anim) │    │  (actual draw)  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 3.2 Implicit Animations

```cpp
// The magic: Just change a property, get animation for free!

class OSFLayer {
public:
    void setOpacity(float opacity) {
        if (OSFTransaction::animationsDisabled()) {
            modelOpacity_ = opacity;
            return;
        }
        
        // Create implicit animation
        float current = presentationOpacity();
        animateProperty("opacity", current, opacity);
        modelOpacity_ = opacity;
    }
    
    float opacity() const {
        auto it = animations_.find("opacity");
        if (it != animations_.end() && it->second->isAnimating()) {
            return it->second->currentValue();
        }
        return modelOpacity_;
    }
    
private:
    float modelOpacity_ = 1.0f;
    std::map<std::string, std::unique_ptr<OSFAnimation>> animations_;
    
    void animateProperty(const std::string& key, float from, float to) {
        float duration = OSFTransaction::animationDuration();
        auto anim = std::make_unique<OSFPropertyAnimation>(duration);
        anim->fromValue = from;
        anim->toValue = to;
        anim->start();
        animations_[key] = std::move(anim);
    }
};
```

## 3.3 Transactions

```cpp
class OSFTransaction {
public:
    static void begin() { stack_.push_back(new OSFTransaction()); }
    static void commit() {
        if (stack_.empty()) return;
        auto* t = stack_.back();
        stack_.pop_back();
        if (t->completionBlock_) { /* schedule */ }
        delete t;
    }
    
    static void setAnimationDuration(float s) { 
        if (!stack_.empty()) stack_.back()->duration_ = s; 
    }
    static float animationDuration() { 
        return stack_.empty() ? 0.25f : stack_.back()->duration_; 
    }
    static void setDisableActions(bool d) {
        if (!stack_.empty()) stack_.back()->disableActions_ = d;
    }
    static bool animationsDisabled() {
        return !stack_.empty() && stack_.back()->disableActions_;
    }
    
private:
    static thread_local std::vector<OSFTransaction*> stack_;
    float duration_ = 0.25f;
    bool disableActions_ = false;
    std::function<void()> completionBlock_;
};
```

## 3.4 Display Link (Frame Sync)

```cpp
class OSFDisplayLink {
public:
    using Callback = std::function<void(float timestamp, float dt)>;
    
    OSFDisplayLink(Callback cb) : callback_(cb) {}
    
    void tick(float timestamp) {
        if (paused_) return;
        float dt = timestamp - lastTimestamp_;
        lastTimestamp_ = timestamp;
        callback_(timestamp, dt);
    }
    
private:
    Callback callback_;
    bool paused_ = false;
    float lastTimestamp_ = 0;
};
```

---

# Part 4: GhostBSD Gershwin Study

## 4.1 What is Gershwin?

- **Platform:** GhostBSD (FreeBSD 14.3)
- **Foundation:** GNUStep (Objective-C)
- **Display:** X11 via gnustep-back
- **Released:** February 2025

## 4.2 Comparison

| Aspect | Gershwin | openSEF |
|--------|----------|---------|
| Language | Objective-C | C++ |
| Display | X11 | Wayland |
| Base | GNUStep | Custom |
| Platform | FreeBSD | NixOS |

## 4.3 Lessons Learned

**What they did right:**
- Leveraged existing GNUStep
- Clear macOS-like identity
- Gradual community preview approach

**What we do better:**
- Native Wayland (no X11 lag)
- C++ (wider adoption)
- Minimal dependencies
- Reproducible NixOS builds

## 4.4 Mistakes to Avoid

1. **X11 Dependency** → We use Wayland
2. **Objective-C Lock-in** → We use C++
3. **Heavy Dependencies** → We stay minimal

---

# Part 5: Implementation Roadmap

## 5.1 Core Classes to Implement

```
opensef-ui/
├── OSFResponder.h/cpp    ← Event chain
├── OSFView.h/cpp         ← Dirty rect tracking
├── OSFWindow.h/cpp       ← Window management
└── OSFEvent.h/cpp        ← Input events

opensef-core/
├── OSFLayer.h/cpp        ← Model/presentation split
├── OSFTransaction.h/cpp  ← Animation batching
├── OSFAnimation.h/cpp    ← Time-based animations
└── OSFDisplayLink.h/cpp  ← Frame sync
```

## 5.2 Priority Order

| Priority | Class | Pattern Source |
|----------|-------|----------------|
| 1 | OSFLayer | CALayer |
| 2 | OSFTransaction | CATransaction |
| 3 | OSFView (refactor) | NSView |
| 4 | OSFAnimation (refactor) | Core Animation |
| 5 | OSFDisplayLink | CADisplayLink |

## 5.3 Key Algorithms Summary

| Algorithm | What It Does | Benefit |
|-----------|--------------|---------|
| Dirty rect tracking | Only redraw changed areas | 10x faster |
| Responder chain | Clean event propagation | Maintainable |
| Implicit animations | Property → animation | Smooth UX |
| Transaction batching | Group changes | Consistent |
| Presentation tree | Animate without blocking | 60fps |

---

# Part 6: Boot, Lock Screen & Shutdown UI

## 6.1 macOS Boot Sequence (What We Emulate)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    macOS Clean Boot Experience                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  What user sees:                                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                             │   │
│  │                      [Apple Logo]                           │   │
│  │                                                             │   │
│  │                   ═══════════════════                       │   │
│  │                      Progress Bar                           │   │
│  │                                                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  What happens behind:                                               │
│  1. EFI/BootROM → boot.efi → Kernel → launchd                      │
│  2. All logs hidden, sent to system log files                       │
│  3. Progress bar synced to boot stages                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

## 6.2 Linux Silent Boot Configuration

**Kernel Parameters (NixOS/GRUB):**
```nix
# /etc/nixos/configuration.nix
boot.kernelParams = [
  "quiet"                           # Suppress kernel messages
  "splash"                          # Enable splash screen
  "loglevel=0"                      # Only show panics
  "rd.udev.log_level=0"             # Silent udev
  "vt.global_cursor_default=0"      # Hide cursor
  "systemd.show_status=false"       # No systemd status
  "rd.systemd.show_status=false"    # No initrd status
];

boot.loader.grub.extraConfig = ''
  GRUB_TIMEOUT=0
  GRUB_TIMEOUT_STYLE=hidden
'';
```

## 6.3 Plymouth Alternatives

| Solution | Pros | Cons |
|----------|------|------|
| **Plymouth** | Standard, maintained | Buggy on some configs |
| **Fbsplash** | Lightweight, early load | Older project |
| **PSplash** | Minimal, embedded-friendly | Limited features |
| **Kernel CONFIG_BOOTSPLASH** | Earliest possible | Requires kernel build |
| **Custom** (openSEF approach) | Full control | More work |

## 6.4 VitusOS Boot Screen Implementation

**Based on mockup: [Bootscreen.png](file:///c:/Users/hp/Documents/VitusOS%20Ares/ui-design/Bootscreen.png)**

```
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│                                                                     │
│                                                                     │
│                                                                     │
│                                                                     │
│                     VitusOS | Ares                                  │
│                                                                     │
│                                                                     │
│                                                                     │
│                     _____________                                   │
│                  (SpaceOrange color loading progress bar)           │
└─────────────────────────────────────────────────────────────────────┘

Background: Solid Black
Elements: VOS logo + minimal spinner - NOTHING ELSE
```

**Implementation:**
```cpp
struct BootTheme {
    static constexpr uint32_t Background = 0x1A1A2E;
    static constexpr uint32_t TextColor = 0xFFFFFF;   // White VOS text
    static constexpr int SpinnerDots = 3;              // Simple 3 dots
};
```

## 6.5 Lock Screen UI

**Based on mockup: [Lockscreen.png](file:///c:/Users/hp/Documents/VitusOS%20Ares/ui-design/Lockscreen.png)**

```
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│                                                                     │
│                   Monday, December 30                               │
│                   10:15                                             │
│                  //_ (password field hidden by default)             │
│                                                                     │
│                                                                     │
│                                                                     │
│                                                                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

Background: Mars wallpaper (slightly dimmed)
Elements: Time + Date ONLY - extremely minimal
NO avatar, NO password box visible by default
```

**Implementation:**
```cpp
class OSFLockScreen {
public:
    void show();
    void hide();
    void updateClock();
    
private:
    // Just time and date - nothing else
    std::string formattedTime();   // "12:34"
    std::string formattedDate();   // "Monday, December 30"
    
    // Wallpaper with slight dim
    static constexpr float DimOpacity = 0.3f;
};
```

## 6.6 Shutdown Screen UI

**Based on mockup: `Shutdown Screen.png`**

```
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│                                                                     │
│                                                                     │
│                                                                     │
│                             goodbye                                 │
│                                                                     │
│                                                                     │
│                                                                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

Background: Solid Black
Elements: Power icons ONLY - no text buttons, no confirmation dialog
Just click an icon to perform action
```

**Implementation:**
```cpp
class OSFPowerDialog {
public:
    void show();
    void hide();
    
    std::function<void(PowerAction)> onAction;
    
private:
    // Just 3 icon buttons - super minimal
    struct IconButton { int x, y, size; PowerAction action; };
    std::array<IconButton, 3> icons_;  // Power, Restart, Sleep
};
```

## 6.7 Implementation Files

```
opensef/opensef-session/
├── include/
│   ├── OSFLockScreen.h      ← Time/date on wallpaper
│   ├── OSFPowerDialog.h     ← 3 power icons
│   └── OSFBootSplash.h      ← VOS + spinner
├── src/
│   ├── OSFLockScreen.cpp
│   ├── OSFPowerDialog.cpp
│   └── OSFBootSplash.cpp

resources/plymouth/vitusos/
├── vitusos.plymouth
└── vitusos.script

## 6.8 Boot Sequence Timeline

```
┌─────────────────────────────────────────────────────────────────────┐
│                    VitusOS Boot Timeline                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  0s     BIOS/UEFI logo (firmware)                                  │
│  ↓                                                                  │
│  1s     Kernel loads (silent, no text)                             │
│  ↓                                                                  │
│  2s     Plymouth starts → VitusOS logo + spinner                   │
│  ↓                                                                  │
│  5s     systemd services load (hidden)                             │
│  ↓                                                                  │
│  8s     openSEF compositor starts                                   │
│  ↓                                                                  │
│  9s     Lock screen appears (if needed) or Desktop                 │
│  ↓                                                                  │
│  10s    Ready for use                                               │
│                                                                     │
│  USER SEES: Logo → Spinner → Desktop (no text ever)                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## References

- **Wayland:** https://wayland.freedesktop.org/
- **wlroots:** https://gitlab.freedesktop.org/wlroots/wlroots
- **GNUStep:** https://github.com/gnustep/libs-gui
- **Core Animation:** Apple Developer Documentation
- **Gershwin:** https://github.com/AtomoSoluciones/gershwin-desktop
- **Plymouth:** https://www.freedesktop.org/wiki/Software/Plymouth/
- **Arch Silent Boot:** https://wiki.archlinux.org/title/Silent_boot

---

*This document is the foundation for building openSEF. No more guessing—we learn from the masters.*
