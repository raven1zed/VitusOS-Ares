/**
 * OSFWindow.cpp - Application Window Implementation
 *
 * Phase 2+3: Windowing Integration + Responder Chain
 *
 * Implements OSFWindow using XDG shell protocol for standard windows.
 * Integrates with OSFApplication for unified event loop.
 *
 * NOW WITH INPUT SUPPORT (wl_seat, wl_pointer, wl_keyboard)
 */

#include <opensef/OSFWindow.h>
#include <opensef/OpenSEFBase.h>
// Needed for OSFView hitTest
#include <opensef/OSFView.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#include <cairo/cairo.h>
#include <cstring>
#include <fcntl.h>
#include <iostream>
#include <linux/input-event-codes.h>
#include <poll.h>
#include <sys/mman.h>
#include <unistd.h>
#include <wayland-client.h>
#include <xkbcommon/xkbcommon.h>

// XDG shell protocol (generated by CMake)
#include "xdg-shell-client-protocol.h"

namespace opensef {

// ============================================================================
// Implementation Details (file-scope)
// ============================================================================

struct WindowImpl {
  // Wayland objects
  wl_display *display = nullptr;
  wl_registry *registry = nullptr;
  wl_compositor *compositor = nullptr;
  wl_shm *shm = nullptr;
  wl_surface *surface = nullptr;
  wl_seat *seat = nullptr;         // Input seat
  wl_pointer *pointer = nullptr;   // Mouse
  wl_keyboard *keyboard = nullptr; // Keyboard

  xdg_wm_base *xdgWmBase = nullptr;
  xdg_surface *xdgSurface = nullptr;
  xdg_toplevel *xdgToplevel = nullptr;

  // XKB state
  xkb_context *xkbContext = nullptr;
  xkb_keymap *xkbKeymap = nullptr;
  xkb_state *xkbState = nullptr;

  // Input state
  double mouseX = 0;
  double mouseY = 0;
  uint32_t lastSerial = 0;

  // Buffer state
  wl_buffer *buffer = nullptr;
  void *shmData = nullptr;
  int shmFd = -1;
  int shmSize = 0;
  cairo_surface_t *cairoSurface = nullptr;

  // State
  bool configured = false;
  bool closed = false;

  // Parent reference
  OSFWindow *window = nullptr;

  // === Phase 3: Mouse Capture and Hover ===
  OSFView *pressedView =
      nullptr; // View that received mouseDown (captures mouse)
  OSFView *hoveredView = nullptr; // View currently under the cursor

  // Helper to dispatch event to view hierarchy
  void dispatchMouseEvent(OSFEvent::Type type, uint32_t button = 0) {
    if (!window)
      return;

    OSFEvent event(type);
    event.setMousePosition(mouseX, mouseY);

    // Map Linux button codes to logical buttons
    if (button == BTN_LEFT)
      event.setKeyCode(1); // logical left
    else if (button == BTN_RIGHT)
      event.setKeyCode(2); // logical right

    // Modifiers from xkb state
    if (xkbState) {
      // Simplified modifier extraction could go here
    }

    auto contentView = window->contentView();
    if (!contentView)
      return;

    // Perform hit test
    OSFView *hitView = contentView->hitTest(mouseX, mouseY);

    // === Mouse Down: Start capture ===
    if (type == OSFEvent::Type::MouseDown) {
      pressedView = hitView;
      if (hitView) {
        hitView->mouseDown(event);
      } else {
        window->mouseDown(event);
      }
      return;
    }

    // === Mouse Up: Deliver to captured view ===
    if (type == OSFEvent::Type::MouseUp) {
      if (pressedView) {
        pressedView->mouseUp(event);
        pressedView = nullptr;
      } else if (hitView) {
        hitView->mouseUp(event);
      } else {
        window->mouseUp(event);
      }
      return;
    }

    // === Mouse Moved: Handle hover transitions ===
    if (type == OSFEvent::Type::MouseMoved) {
      // If mouse is captured (pressed), send to pressed view
      if (pressedView) {
        pressedView->mouseMoved(event);
        return;
      }

      // Handle hover enter/exit
      if (hitView != hoveredView) {
        // Exit old hovered view
        if (hoveredView) {
          OSFEvent exitEvent(OSFEvent::Type::FocusOut);
          exitEvent.setMousePosition(mouseX, mouseY);
          hoveredView->mouseMoved(exitEvent);
        }
        // Enter new hovered view
        hoveredView = hitView;
        if (hoveredView) {
          OSFEvent enterEvent(OSFEvent::Type::FocusIn);
          enterEvent.setMousePosition(mouseX, mouseY);
          hoveredView->mouseMoved(enterEvent);
        }
      }

      // Normal mouse move
      if (hitView) {
        hitView->mouseMoved(event);
      }
    }
  }
};

// ============================================================================
// Input Listeners
// ============================================================================

// --- Keyboard ---

static void keyboard_keymap(void *data, wl_keyboard *, uint32_t format,
                            int32_t fd, uint32_t size) {
  auto *impl = static_cast<WindowImpl *>(data);
  if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1) {
    close(fd);
    return;
  }

  char *map_str = (char *)mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
  if (map_str == MAP_FAILED) {
    close(fd);
    return;
  }

  if (impl->xkbKeymap)
    xkb_keymap_unref(impl->xkbKeymap);
  if (impl->xkbState)
    xkb_state_unref(impl->xkbState);

  impl->xkbKeymap = xkb_keymap_new_from_string(impl->xkbContext, map_str,
                                               XKB_KEYMAP_FORMAT_TEXT_V1,
                                               XKB_KEYMAP_COMPILE_NO_FLAGS);
  munmap(map_str, size);
  close(fd);

  if (impl->xkbKeymap) {
    impl->xkbState = xkb_state_new(impl->xkbKeymap);
  }
}

static void keyboard_enter(void *data, wl_keyboard *, uint32_t serial,
                           wl_surface *, wl_array *) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->lastSerial = serial;
  // Window gained focus
}

static void keyboard_leave(void *data, wl_keyboard *, uint32_t serial,
                           wl_surface *) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->lastSerial = serial;
  // Window lost focus
}

static void keyboard_key(void *data, wl_keyboard *, uint32_t serial,
                         uint32_t /*time*/, uint32_t key, uint32_t state) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->lastSerial = serial;
  if (!impl->window || !impl->xkbState)
    return;

  // Key is raw scancode, offset by 8 required for XKB
  xkb_keysym_t sym = xkb_state_key_get_one_sym(impl->xkbState, key + 8);

  OSFEvent::Type type = (state == WL_KEYBOARD_KEY_STATE_PRESSED)
                            ? OSFEvent::Type::KeyDown
                            : OSFEvent::Type::KeyUp;

  OSFEvent event(type);
  event.setKeyCode(sym); // Use keysym as keycode for now

  // Dispatch to window (which routes to First Responder)
  if (type == OSFEvent::Type::KeyDown)
    impl->window->keyDown(event);
  else
    impl->window->keyUp(event);
}

static void keyboard_modifiers(void *data, wl_keyboard *, uint32_t serial,
                               uint32_t mods_depressed, uint32_t mods_latched,
                               uint32_t mods_locked, uint32_t group) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->lastSerial = serial;
  if (impl->xkbState) {
    xkb_state_update_mask(impl->xkbState, mods_depressed, mods_latched,
                          mods_locked, 0, 0, group);
  }
}

static void keyboard_repeat_info(void *, wl_keyboard *, int32_t, int32_t) {}

static const wl_keyboard_listener keyboardListener = {
    keyboard_keymap, keyboard_enter,     keyboard_leave,
    keyboard_key,    keyboard_modifiers, keyboard_repeat_info,
};

// --- Pointer ---

static void pointer_enter(void *data, wl_pointer *, uint32_t serial,
                          wl_surface *, wl_fixed_t sx, wl_fixed_t sy) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->lastSerial = serial;
  impl->mouseX = wl_fixed_to_double(sx);
  impl->mouseY = wl_fixed_to_double(sy);
}

static void pointer_leave(void *data, wl_pointer *, uint32_t serial,
                          wl_surface *) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->lastSerial = serial;
}

static void pointer_motion(void *data, wl_pointer *, uint32_t /*time*/,
                           wl_fixed_t sx, wl_fixed_t sy) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->mouseX = wl_fixed_to_double(sx);
  impl->mouseY = wl_fixed_to_double(sy);

  impl->dispatchMouseEvent(OSFEvent::Type::MouseMoved);
}

static void pointer_button(void *data, wl_pointer *, uint32_t serial,
                           uint32_t /*time*/, uint32_t button, uint32_t state) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->lastSerial = serial;

  OSFEvent::Type type = (state == WL_POINTER_BUTTON_STATE_PRESSED)
                            ? OSFEvent::Type::MouseDown
                            : OSFEvent::Type::MouseUp;

  impl->dispatchMouseEvent(type, button);
}

static void pointer_axis(void *, wl_pointer *, uint32_t, uint32_t, wl_fixed_t) {
}
static void pointer_frame(void *, wl_pointer *) {}
static void pointer_axis_source(void *, wl_pointer *, uint32_t) {}
static void pointer_axis_stop(void *, wl_pointer *, uint32_t, uint32_t) {}
static void pointer_discrete(void *, wl_pointer *, uint32_t, int32_t) {}

static const wl_pointer_listener pointerListener = {
    pointer_enter,       pointer_leave,     pointer_motion,
    pointer_button,      pointer_axis,      pointer_frame,
    pointer_axis_source, pointer_axis_stop, pointer_discrete,
};

// --- Seat ---

static void seat_capabilities(void *data, wl_seat *seat,
                              uint32_t capabilities) {
  auto *impl = static_cast<WindowImpl *>(data);
  bool hasPointer = capabilities & WL_SEAT_CAPABILITY_POINTER;
  bool hasKeyboard = capabilities & WL_SEAT_CAPABILITY_KEYBOARD;

  if (hasPointer && !impl->pointer) {
    impl->pointer = wl_seat_get_pointer(seat);
    wl_pointer_add_listener(impl->pointer, &pointerListener, impl);
  } else if (!hasPointer && impl->pointer) {
    wl_pointer_release(impl->pointer);
    impl->pointer = nullptr;
  }

  if (hasKeyboard && !impl->keyboard) {
    impl->keyboard = wl_seat_get_keyboard(seat);
    wl_keyboard_add_listener(impl->keyboard, &keyboardListener, impl);
  } else if (!hasKeyboard && impl->keyboard) {
    wl_keyboard_release(impl->keyboard);
    impl->keyboard = nullptr;
  }
}

static void seat_name(void *, wl_seat *, const char *) {}

static const wl_seat_listener seatListener = {
    seat_capabilities,
    seat_name,
};

// ============================================================================
// Wayland Protocol Listeners
// ============================================================================

static void registryGlobal(void *data, wl_registry *registry, uint32_t name,
                           const char *interface, uint32_t /*version*/) {
  auto *impl = static_cast<WindowImpl *>(data);

  if (strcmp(interface, wl_compositor_interface.name) == 0) {
    impl->compositor = static_cast<wl_compositor *>(
        wl_registry_bind(registry, name, &wl_compositor_interface, 4));
  } else if (strcmp(interface, wl_shm_interface.name) == 0) {
    impl->shm = static_cast<wl_shm *>(
        wl_registry_bind(registry, name, &wl_shm_interface, 1));
  } else if (strcmp(interface, xdg_wm_base_interface.name) == 0) {
    impl->xdgWmBase = static_cast<xdg_wm_base *>(
        wl_registry_bind(registry, name, &xdg_wm_base_interface, 1));
  } else if (strcmp(interface, wl_seat_interface.name) == 0) {
    impl->seat = static_cast<wl_seat *>(
        wl_registry_bind(registry, name, &wl_seat_interface, 7));
    wl_seat_add_listener(impl->seat, &seatListener, impl);
  }
}

// ... rest of static listeners (unchanged) ...
static void registryGlobalRemove(void *, wl_registry *, uint32_t) {}
static const wl_registry_listener registryListener = {registryGlobal,
                                                      registryGlobalRemove};
static void xdgWmBasePing(void *, xdg_wm_base *base, uint32_t serial) {
  xdg_wm_base_pong(base, serial);
}
static const xdg_wm_base_listener xdgWmBaseListener = {xdgWmBasePing};
static void xdgSurfaceConfigure(void *data, xdg_surface *surface,
                                uint32_t serial) {
  auto *impl = static_cast<WindowImpl *>(data);
  xdg_surface_ack_configure(surface, serial);
  impl->configured = true;
}
static const xdg_surface_listener xdgSurfaceListener = {xdgSurfaceConfigure};
static void xdgToplevelConfigure(void *data, xdg_toplevel *, int32_t width,
                                 int32_t height, wl_array *) {
  auto *impl = static_cast<WindowImpl *>(data);
  if (width > 0 && height > 0 && impl->window)
    impl->window->setSize(width, height);
}
static void xdgToplevelClose(void *data, xdg_toplevel *) {
  auto *impl = static_cast<WindowImpl *>(data);
  impl->closed = true;
}
static void xdgToplevelConfigureBounds(void *, xdg_toplevel *, int32_t,
                                       int32_t) {}
static void xdgToplevelWmCapabilities(void *, xdg_toplevel *, wl_array *) {}
static const xdg_toplevel_listener xdgToplevelListener = {
    xdgToplevelConfigure, xdgToplevelClose, xdgToplevelConfigureBounds,
    xdgToplevelWmCapabilities};

// ============================================================================
// Buffer Creation (Unchanged)
// ============================================================================

static int createShmFile(int size) {
  char name[] = "/tmp/osf-window-XXXXXX";
  int fd = mkstemp(name);
  if (fd < 0)
    return -1;
  unlink(name);
  if (ftruncate(fd, size) < 0) {
    ::close(fd);
    return -1;
  }
  return fd;
}

static bool createBuffer(WindowImpl *impl, int width, int height) {
  // reusing existing buffer creation logic...
  int stride = width * 4;
  int size = stride * height;
  if (impl->shmData && impl->shmSize == size)
    return true;
  if (impl->cairoSurface) {
    cairo_surface_destroy(impl->cairoSurface);
    impl->cairoSurface = nullptr;
  }
  if (impl->buffer) {
    wl_buffer_destroy(impl->buffer);
    impl->buffer = nullptr;
  }
  if (impl->shmData) {
    munmap(impl->shmData, impl->shmSize);
    impl->shmData = nullptr;
  }
  if (impl->shmFd >= 0) {
    ::close(impl->shmFd);
    impl->shmFd = -1;
  }

  impl->shmFd = createShmFile(size);
  if (impl->shmFd < 0)
    return false;

  impl->shmData =
      mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, impl->shmFd, 0);
  if (impl->shmData == MAP_FAILED) {
    ::close(impl->shmFd);
    impl->shmFd = -1;
    impl->shmData = nullptr;
    return false;
  }
  impl->shmSize = size;

  wl_shm_pool *pool = wl_shm_create_pool(impl->shm, impl->shmFd, size);
  impl->buffer = wl_shm_pool_create_buffer(pool, 0, width, height, stride,
                                           WL_SHM_FORMAT_ARGB8888);
  wl_shm_pool_destroy(pool);
  impl->cairoSurface = cairo_image_surface_create_for_data(
      static_cast<unsigned char *>(impl->shmData), CAIRO_FORMAT_ARGB32, width,
      height, stride);
  return true;
}

// ============================================================================
// OSFWindow Implementation
// ============================================================================

struct OSFWindow::Impl : public WindowImpl {};

OSFWindow::OSFWindow(int width, int height, const std::string &title)
    : title_(title), width_(width), height_(height),
      impl_(std::make_unique<Impl>()) {
  impl_->window = this;
  impl_->xkbContext = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
  OSFApplication::shared().registerWindow(this);
}

OSFWindow::~OSFWindow() {
  OSFApplication::shared().unregisterWindow(this);
  disconnect();
  // Cleanup XKB
  if (impl_->xkbState)
    xkb_state_unref(impl_->xkbState);
  if (impl_->xkbKeymap)
    xkb_keymap_unref(impl_->xkbKeymap);
  if (impl_->xkbContext)
    xkb_context_unref(impl_->xkbContext);
}

bool OSFWindow::connect(const char *displayName) {
  impl_->display = wl_display_connect(displayName);
  if (!impl_->display) {
    std::cerr << "[OSFWindow] Failed to connect to Wayland display"
              << std::endl;
    return false;
  }

  impl_->registry = wl_display_get_registry(impl_->display);
  wl_registry_add_listener(impl_->registry, &registryListener, impl_.get());
  wl_display_roundtrip(impl_->display);

  if (!impl_->compositor || !impl_->shm || !impl_->xdgWmBase || !impl_->seat) {
    std::cerr << "[OSFWindow] Missing required Wayland globals (Compositor, "
                 "SHM, XDG, or Seat)"
              << std::endl;
    // disconnect(); // Let the caller or destructor handle cleanup, or be safer
    return false;
  }

  xdg_wm_base_add_listener(impl_->xdgWmBase, &xdgWmBaseListener, impl_.get());
  return true;
}

void OSFWindow::disconnect() {
  // Cleanup Wayland objects
  if (impl_->pointer) {
    wl_pointer_release(impl_->pointer);
    impl_->pointer = nullptr;
  }
  if (impl_->keyboard) {
    wl_keyboard_release(impl_->keyboard);
    impl_->keyboard = nullptr;
  }
  if (impl_->seat) {
    wl_seat_release(impl_->seat);
    impl_->seat = nullptr;
  }

  if (impl_->cairoSurface) {
    cairo_surface_destroy(impl_->cairoSurface);
    impl_->cairoSurface = nullptr;
  }
  if (impl_->buffer) {
    wl_buffer_destroy(impl_->buffer);
    impl_->buffer = nullptr;
  }
  if (impl_->shmData) {
    munmap(impl_->shmData, impl_->shmSize);
    impl_->shmData = nullptr;
  }
  if (impl_->shmFd >= 0) {
    ::close(impl_->shmFd);
    impl_->shmFd = -1;
  }

  if (impl_->xdgToplevel) {
    xdg_toplevel_destroy(impl_->xdgToplevel);
    impl_->xdgToplevel = nullptr;
  }
  if (impl_->xdgSurface) {
    xdg_surface_destroy(impl_->xdgSurface);
    impl_->xdgSurface = nullptr;
  }
  if (impl_->surface) {
    wl_surface_destroy(impl_->surface);
    impl_->surface = nullptr;
  }
  if (impl_->xdgWmBase) {
    xdg_wm_base_destroy(impl_->xdgWmBase);
    impl_->xdgWmBase = nullptr;
  }
  if (impl_->shm) {
    wl_shm_destroy(impl_->shm);
    impl_->shm = nullptr;
  }
  if (impl_->compositor) {
    wl_compositor_destroy(impl_->compositor);
    impl_->compositor = nullptr;
  }
  if (impl_->registry) {
    wl_registry_destroy(impl_->registry);
    impl_->registry = nullptr;
  }
  if (impl_->display) {
    wl_display_disconnect(impl_->display);
    impl_->display = nullptr;
  }
}

void OSFWindow::show() {
  if (!impl_->display || !impl_->compositor || !impl_->xdgWmBase)
    return;
  if (impl_->surface)
    return;

  impl_->surface = wl_compositor_create_surface(impl_->compositor);
  impl_->xdgSurface =
      xdg_wm_base_get_xdg_surface(impl_->xdgWmBase, impl_->surface);
  xdg_surface_add_listener(impl_->xdgSurface, &xdgSurfaceListener, impl_.get());
  impl_->xdgToplevel = xdg_surface_get_toplevel(impl_->xdgSurface);
  xdg_toplevel_add_listener(impl_->xdgToplevel, &xdgToplevelListener,
                            impl_.get());

  xdg_toplevel_set_title(impl_->xdgToplevel, title_.c_str());
  xdg_toplevel_set_app_id(impl_->xdgToplevel, "opensef.app");

  wl_surface_commit(impl_->surface);
  wl_display_roundtrip(impl_->display);

  while (!impl_->configured && wl_display_dispatch(impl_->display) != -1) {
  }
  visible_ = true;
}

void OSFWindow::hide() {
  // Basic cleanup of toplevel resources
  if (impl_->xdgToplevel) {
    xdg_toplevel_destroy(impl_->xdgToplevel);
    impl_->xdgToplevel = nullptr;
  }
  if (impl_->xdgSurface) {
    xdg_surface_destroy(impl_->xdgSurface);
    impl_->xdgSurface = nullptr;
  }
  if (impl_->surface) {
    wl_surface_destroy(impl_->surface);
    impl_->surface = nullptr;
  }
  visible_ = false;
}

void OSFWindow::close() {
  running_ = false;
  hide();
}
void OSFWindow::setTitle(const std::string &title) {
  title_ = title;
  if (impl_->xdgToplevel)
    xdg_toplevel_set_title(impl_->xdgToplevel, title.c_str());
}
void OSFWindow::setSize(int width, int height) {
  if (width_ == width && height_ == height)
    return;
  width_ = width;
  height_ = height;
  if (resizeCallback_)
    resizeCallback_(width, height);
}

// ... runEventLoop (unchanged) ...
void OSFWindow::runEventLoop() {
  if (!impl_->display)
    return;
  running_ = true;
  int fd = wl_display_get_fd(impl_->display);
  while (running_ && !impl_->closed) {
    wl_display_flush(impl_->display);
    if (impl_->configured && createBuffer(impl_.get(), width_, height_)) {
      cairo_t *cr = cairo_create(impl_->cairoSurface);

      // === VitusOS CSD (Client Side Decorations) ===

      // 1. Background (Dark Mode Glass: LunarGray #2D2D2D with Alpha)
      cairo_save(cr);
      cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
      cairo_set_source_rgba(cr, 0.18, 0.18, 0.18, 0.85); // 85% opacity
      cairo_paint(cr);
      cairo_restore(cr);

      // 2. Titlebar (Slightly lighter, also glass)
      cairo_set_source_rgba(cr, 0.24, 0.24, 0.24, 0.90); // 90% opacity
      cairo_rectangle(cr, 0, 0, width_, 30);             // 30px height
      cairo_fill(cr);

      // 3. Traffic Lights
      // Red
      cairo_set_source_rgba(cr, 1.0, 0.37, 0.35, 1.0); // #FF5F5A
      cairo_arc(cr, 20, 15, 6, 0, 2 * M_PI);
      cairo_fill(cr);
      // Yellow
      cairo_set_source_rgba(cr, 1.0, 0.73, 0.19, 1.0); // #FFBB30
      cairo_arc(cr, 40, 15, 6, 0, 2 * M_PI);
      cairo_fill(cr);
      // Green
      cairo_set_source_rgba(cr, 0.16, 0.78, 0.25, 1.0); // #28C840
      cairo_arc(cr, 60, 15, 6, 0, 2 * M_PI);
      cairo_fill(cr);

      // 4. Title Text (White)
      if (!title_.empty()) {
        cairo_set_source_rgba(cr, 0.9, 0.9, 0.9, 1.0);
        cairo_select_font_face(cr, "Inter", CAIRO_FONT_SLANT_NORMAL,
                               CAIRO_FONT_WEIGHT_BOLD);
        cairo_set_font_size(cr, 13);
        cairo_text_extents_t extents;
        cairo_text_extents(cr, title_.c_str(), &extents);
        cairo_move_to(cr, (width_ - extents.width) / 2, 20);
        cairo_show_text(cr, title_.c_str());
      }

      // Separator Line
      cairo_set_source_rgba(cr, 0.1, 0.1, 0.1, 0.5);
      cairo_move_to(cr, 0, 30);
      cairo_line_to(cr, width_, 30);
      cairo_stroke(cr);

      if (drawCallback_)
        drawCallback_(cr, width_, height_);
      cairo_destroy(cr);
      wl_surface_attach(impl_->surface, impl_->buffer, 0, 0);
      wl_surface_damage_buffer(impl_->surface, 0, 0, width_, height_);
      wl_surface_commit(impl_->surface);
    }
    struct pollfd pfd = {fd, POLLIN, 0};
    if (poll(&pfd, 1, 16) > 0) {
      if (pfd.revents & POLLIN && wl_display_dispatch(impl_->display) == -1)
        break;
    }
  }
  if (impl_->closed && closeCallback_)
    closeCallback_();
}

void OSFWindow::stopEventLoop() { running_ = false; }

// === Phase 3: Responder Chain ===

OSFResponder *OSFWindow::nextResponder() const { return nullptr; }

// Default handlers if no view handles it
bool OSFWindow::mouseDown(OSFEvent &event) {
  if (firstResponder_ && firstResponder_->mouseDown(event))
    return true;
  return OSFResponder::mouseDown(event);
}

bool OSFWindow::keyDown(OSFEvent &event) {
  if (firstResponder_ && firstResponder_->keyDown(event))
    return true;
  return OSFResponder::keyDown(event);
}

// ... rest is same ...
bool OSFWindow::makeFirstResponder(OSFResponder *responder) {
  if (responder && !responder->acceptsFirstResponder())
    return false;
  if (firstResponder_)
    firstResponder_->resignFirstResponder();
  firstResponder_ = responder;
  if (firstResponder_)
    firstResponder_->becomeFirstResponder();
  return true;
}
void OSFWindow::setContentView(std::shared_ptr<OSFView> view) {
  contentView_ = view;
}
int OSFWindow::displayFd() const {
  return impl_->display ? wl_display_get_fd(impl_->display) : -1;
}

bool OSFWindow::processEvents() {
  if (!impl_->display || impl_->closed)
    return false;
  wl_display_flush(impl_->display);

  if (impl_->configured && createBuffer(impl_.get(), width_, height_)) {
    cairo_t *cr = cairo_create(impl_->cairoSurface);

    // === VitusOS CSD (Client Side Decorations) ===

    // 1. Background (Dark Mode Glass: LunarGray #2D2D2D with Alpha)
    cairo_save(cr);
    cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
    cairo_set_source_rgba(cr, 0.18, 0.18, 0.18, 0.85); // 85% opacity
    cairo_paint(cr);
    cairo_restore(cr);

    // 2. Titlebar (Slightly lighter, also glass)
    cairo_set_source_rgba(cr, 0.24, 0.24, 0.24, 0.90); // 90% opacity
    cairo_rectangle(cr, 0, 0, width_, 30);             // 30px height
    cairo_fill(cr);

    // 3. Traffic Lights
    // Red
    cairo_set_source_rgba(cr, 1.0, 0.37, 0.35, 1.0); // #FF5F5A
    cairo_arc(cr, 20, 15, 6, 0, 2 * M_PI);
    cairo_fill(cr);
    // Yellow
    cairo_set_source_rgba(cr, 1.0, 0.73, 0.19, 1.0); // #FFBB30
    cairo_arc(cr, 40, 15, 6, 0, 2 * M_PI);
    cairo_fill(cr);
    // Green
    cairo_set_source_rgba(cr, 0.16, 0.78, 0.25, 1.0); // #28C840
    cairo_arc(cr, 60, 15, 6, 0, 2 * M_PI);
    cairo_fill(cr);

    // 4. Title Text (White)
    if (!title_.empty()) {
      cairo_set_source_rgba(cr, 0.9, 0.9, 0.9, 1.0);
      cairo_select_font_face(cr, "Inter", CAIRO_FONT_SLANT_NORMAL,
                             CAIRO_FONT_WEIGHT_BOLD);
      cairo_set_font_size(cr, 13);
      cairo_text_extents_t extents;
      cairo_text_extents(cr, title_.c_str(), &extents);
      cairo_move_to(cr, (width_ - extents.width) / 2, 20);
      cairo_show_text(cr, title_.c_str());
    }

    // Separator Line
    cairo_set_source_rgba(cr, 0.1, 0.1, 0.1, 0.5);
    cairo_move_to(cr, 0, 30);
    cairo_line_to(cr, width_, 30);
    cairo_stroke(cr);

    if (drawCallback_)
      drawCallback_(cr, width_, height_);
    cairo_destroy(cr);
    wl_surface_attach(impl_->surface, impl_->buffer, 0, 0);
    wl_surface_damage_buffer(impl_->surface, 0, 0, width_, height_);
    wl_surface_commit(impl_->surface);
  }

  if (wl_display_dispatch_pending(impl_->display) == -1)
    return false;
  return !impl_->closed;
}

std::shared_ptr<OSFWindow> OSFWindow::create(int width, int height,
                                             const std::string &title) {
  return std::make_shared<OSFWindow>(width, height, title);
}

} // namespace opensef
